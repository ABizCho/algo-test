/*

#키워드 : 
	최대, 최소 => 이진탐색 or 힙
	이 문제의 경우, 이진탐색

	결정 알고리즘의 경우 보통
	파라메트릭 서치로 변환된 접근으로,
	최적해의 후보를 전부 배열(후보)에 정렬해   담아놓고
	이분으로 절반씩 쳐가며 정답에 근접해가는 방식

문제의 input 확인

	1. 입국심사 기다리는 사람 N은 
		1명 이상 10억명 이하

	2. 각 심사관이 한명 심사 걸리는 시간 (time)은
		1분 이상 10억분 이하

	3. 심사관(times.length)은 1명 이상 10만 이하

	
	
	따라서, 10억명, 10억분을 해결하기 위한 아이디어
	=> O(N)은 절대불가.
		=> O(logN)은 가능하겠다.
			=> O(logN)의 대표격 이진탐색 수행
			-> 이진탐색은 정렬해야 하지만,
			-> times는 최대 10만 이하로 정렬(O(n))도 시도 가능

	
	우리는 특정 답을 찾는 것이 아니다.
	우리가 찾는 것은 최소 몇분에 모든 심사가 끝나는가.
	=> <결정 문제> = <이진탐색> = <parametric search>

	결정문제란? 
	어떤 형식체계에서 "예"-"아니오" 가 있는 문제

	파라메트릭 서치
	조합최적화를 위한 알고리즘 설계에서,
	최적화 문제 -> 결정 문제로 바꾸어 푸는 것.
*/

// 위의 논리대로 이분탐색 전략 설정
/* 
	# 이진탐색 내 최적해 후보는,
	최소 1분 ~ 10억분*n 사이에 있음

	#면접관들이 몇명을 처리하는가?

	#처리 가능한 입국자가 n보다 작다면
	분을 올려야 하고, 입국자가 n보다 크다면 분을 낮춰야 함.

	#면접관이 시간대비 몇명을 처리할 수 있는가?
		=> 시간 / 심사시간 = 심사관당 처리 가능한 입국자 수
*/

/* 
	반성!!!
	
	일단, 힌트를 명확히 정리, 인식해야 함

	1.
	이 문제의 경우 
	
	(1) <최소> 라는 힌트로
		이진탐색, 힙 으로 아이디어를 떠올릴 수 있었음

	(2) <10억>이라는 input으로
	O(N)은 불가능하다는 것을 떠올리고
	선형이 아닌 이진탐색을 떠올릴 수 있었음

	이처럼, 키워드와 input을 명확히 인지하여 아이디어를 설정해나가야 함.


	2.
	이진탐색이라는 아이디어를 세웠으면,
	적어도 그에 맞는 템플릿이라도 분명히
	작성하고 시작해야 함.
	
	아이디어가 나오지 않더라도,
	템플릿을 보며 아이디어를 찾아갈 수 있음.

	이 문제의 경우 BinSearch함수 템플릿을 작성할 수 있었음

	+ 보통의 경우 이진탐색 템플릿은

	while(left <= right){
		if (anyFunc(...)){
			ans = Math.min/max(mid,ans);
			lt = mid + 1; 
			(or)
			rt = mid - 1;
		}
		else {
			lt = mid + 1;
			(or)
			rt = mid - 1;
		}
	}
	의 anyFunc에 해당하는 yes or not판별 함수 및 조건
	만 달라지고, 나머지는 완벽히 똑같이 풀 수 있는
	경우가 대다수임.


*/

function solution(n, times) {
  // 이분탐색은 무조건 정렬상태를 대상으로 함
  //	=> 정렬 내장함수 : O(NlogN)
  times.sort((a, b) => a - b);
  let left = 1;
  let right = times[times.length - 1] * n;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    const sum = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);

    if (sum < n) {// 현재 후보가 충분하지 않다면, 더 큰 후보 탐색
      left = mid + 1;
    } else { // 충분한데, 최적화 가능성을 더 탐색
      right = mid - 1;
    }
  }
  return left;
}

console.log(solution(6, [7, 10]));
